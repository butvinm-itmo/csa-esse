Виктор Брет ставит себя на место разработчика в 1973 году и рассуждает о программировании будущего.

**Переход от программирования к прямому управлению данными** иллюстрируется программой Sketchpad, которая автоматически корректирует графические элементы. Это позволяло проектировать сложные объекты, например, мосты, автоматически оптимизируя их устойчивость без необходимости прописывать каждое правило вручную.

Если вы, как и я, не сразу поняли, в чем суть этой идеи, не расстраивайтесь - просто вы не в 1973. Иначе, для того чтобы спроектировать показанный нам мост, необходимо было бы написать программу. И чтобы нарисовать логотип для вашего стартапа, вам тоже пришлось бы задать его программно. Посчитать бухгалтерский отчет? - снова нужно писать код.

В современном мире, где для каждой прикладной задачи существует специальный софт, такой как Excel, Photoshop или AutoCAD, данный подход кажется очевидным и мы даже не задумываемся о том, что могло быть иначе.

**Описывая цели вместо конкретных шагов для их достижения**, системы вроде Prolog, pattern matching, и RegExp иллюстрируют уход от процедурного программирования.

Идея не описывать каждый шаг, казалось бы, обречена на успех, ведь человек мыслит концепциями, а не командами. И популярность таких систем как Prolog и Coq, функционального программирования и "фреймворков" (в хорошем смысле этого слова) доказывает это.

Но к сожалению, ни ко всем проблемам это подход применим, и в 2024 году мы все еще пишем на C. Это обусловлено в первую очередь тем, что люди пишут программы для машин, а их естественный язык - инструкции. Поэтому, чем ближе наша задача к железу, тем чаще нам приходится отказываться от абстракций. Однако в защиту императивного подхода мне бы хотелось привести доклад Григория Петрова "Нейрофизиология сложности кода", показывающий, что мы воспринимаем код целыми блоками и соотносим с концепциями нашей задачи.

В представлении программ в виде блок-схем и разбиение их на концептуальные части, а также в графических интерфейсах Дугласа Энгельбарта, Виктор Брет видит **переход от текстов к пространственному представлению программ.**

Здесь стоит разделить две разные идеи - процесс разработки программ и взаимодействие с ними. Вторая идея безусловно завоевала мир - практически вся информация сейчас представлена в графическом виде с использованием анимаций и реактивных интерфейсов - такого развития не предугадал даже Дуглас Энгельбарт.

А вот вокруг первой споры все еще не умолкают. Если переход к графическим IDE с всевозможными подсветками, подсказками и миллионами окон все согласились (про vim пожалуй промолчим), то блочное программирование преодолело более долгий и неоднозначный путь. Возможно, кто-то даже помнит, как люди верили, что скоро бизнес будет создавать программы, рисуя UML. Чуда не случилось, но этот подход развился в так называемые Low-Code и No-Code решения. И несмотря на то, что эти решения стали успешными - Wordpress тому живой пример - многие программисты относятся к ним пренебрежительно. Но нужно понимать, что несмотря на ограничения и невозможность применять их для всех задач, есть ряд ниш, где они очень удобны - MVP, шаблонные сайты, не программистские задачи (описание шейдеров, игровых скриптов).

Докладчик также пророчит **развитие многозадачности и многопроцессорности** и необходимость подстроиться под новые требования. Автор считает текущие подходы устаревшими и предлагает модель акторов.

Это предсказание также оказалось успешным. Без параллельных вычислений на GPU (очень похожих на схему мультипроцессора, которую показывал Виктор Брет) невозможно представить работу игр, софта для обработки графики, научных вычислений и AI. Сложная модель акторов, не прижившаяся в коде (да простят меня Erlang программисты), нашла применение в архитектуре в виде так называемых месседж-брокеров (кафка, rabbitmq), а на смену потокам пришло асинхронное программирование и каналы.
