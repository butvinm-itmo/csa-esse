Данное эссе посвещено докладу Джека Рашера "Stop Writing Dead Programs".

Сразу заметим, что название доклада имеет мало общего с его содержимым. Хотя в начале Джек и рассказывает, о том, как в молодости они писали на перфокартах и ждали несколько часов, пока программу перенесут и запусят, а где-то в середине срывается на 80-символьные терминалы, основной темой доклада все-таки являются идеи для улучшения процесса разработки программного обеспечения, которые кажутся Рашеру существенными.

В целом, все его идеи направлены на получения более короткого цикла обратной связи. Чтобы понять его идеи, стоит сначала принять во внимание его мысль о том, что программа не извояние из мрамора, единожды написанная и отправленная в продакш, никогда не изменяемая, а постоянно изменяющаяся система. И процесс разработки такой системы должен поддерживать внесения небольших изменений с моментальным откликом.

В начале Рашер демонстрирует простой пример кода, решение которого, в зависимости от инструмента, требует все меньше усилий на поддрежание внешних условий, и все болше стермится к прямому описанию задачи: так, в ассемблерном коде приходится в ручную поддерживать состояние регистров и стека, в Си отдельно предавать размер массива, но уже Haskell и APL оптимизируют этот процесс, позволяя программисту сосредоточиться на самой задаче. Так Рашер пытается показать, что мы пишем много кода, напрямую не решающего нашу проблему, и что существуют лучшие подходы, к которым мы должны стремиться. И тут я уже хотел с ним не согласиться, потому что, кто сказал, что код вообще должен быть полезным, а не просто приносить удовольствие от написания, но далее Джек Рашер исправился, разрешив хаскелистам и дальше развлекать себя преезодами модан в эндофункторах. В любом случая, данная идея очень спорная. Нужно понимать, что такой потрясающей гармонии между кодом и задачей можно добиться, только исполью для каждой задачи свой узкоспециализированный инструмент, но напрактике 99% языков - general purpose - и они позволяют решать разные задачи, хоть это и требует компромиссов (просто попробуйте написать http сервер на APL, а не этот игрушечный пример со сложением).

Следующей важной особенностью средств разработки, названной Рашером, является возможность горячей перезагрузки. Рашер упоминает в том числе Eralng, где эта фича является основопологающей и закладывалась еще при проектировании языка. Многие другие системы сейчас также поддерживают эту особенность - это, например, все, что связано с разработкой UI. К сожалению, поддержка горячей перезагрузки - сложное архитектурное решение, которое требует много услий и компромиссов при внедрении, особенно в компилируемых языках (как минимум, это убивает возможность многих оптимизаций, а значит, компилятору понадобится два режима сборки, что уже добавляет сложности). Но при этом, такую систему довольно легко доабвить в любую существующую технологий "сбоку", хоть это и не так удобно. Я буквально пару дней назад видел, как человек написал систему горячей перезагрузки для C за 10 минут, и может быть, даже разумно не включать такую фичу в язык, а оставить на усмотрение разработчика.

Еще одна фича, которая кажется Рашеру важной, возможность инкрементальной типизации. Как уже было сказано, программирование - непрерывный процесс и мы не можем изначально предугадать все особенности нашего кода. Поэтому Рашер предлагает отказаться от идеи обязательного прописывания всех типов изначально, а также демонстрирует учебный инструмент для постеменного заполнения типов в программе. В целом, эта идея кажется мне разумной, если говорить о типах, если мы не говорим о Type Driven Development и типах как спецификации. Более того, многие языки предоставляют нам такую возможность - в C# есть тип dynamic, а в Idris - так называемые type holes, чем-то похожие на предложенный Рашером инструмент, позволяющие оставить некоторые типы неопределенными и заполнить их позже.

Далее Рашер говорит о важности интроспекции состояния программы. Он также демонстрирует написанную им Clojure библиотеку, позволяющую в редиме реального времени следить за изменением данных в программе. Рашер считает важным иметь возможность в любой момент времени не только посмотреть на состояние программы, но и изменить его, повлиять на код и порядок исполения. С одной стороны, польза от этой идеи понятна и я в какой-то степени согласен с ней, но вообще, делать такие приколы в продакшене - плохая идея. Но как инструмент для отладки - это сильно упрощает работу со сложными долгоживущими процессами. Но опять-таки, как и с горячей перезагрузкой, внедрение такой системы в язык нетривиально, а юз кейсы достаточно редки, чтобы переложить ответственность на реализацию этого на самих разработчиков (кто не писал принты и не менял код для отладки?)

Последняя идея Рашера, тесно связана с предыдущей - визуализация данных. Рашер показывает несколько примеров инструментов визуализации. Самыми распространнными такими средставами, пожалуй, являются Jupyter Notebook и аналоги. В определенных сферах, таких как научные иследования и ML, это и вправду сильно помогает в написании, но в большинстве случаев, по-моему, наш код все-таки не требует таких ухищрений. И ради всего святого, не вставляйте посреди моего кода PNGшку и экслель таблицу, это ужасно. Хотя недавно у меня была задача, требующая написания сложного алгоритма анализа строковых данных, и в итоге я пришел к тому, что написал для себя утилиту, отображающую шаги в виде графов. Но опять-таки - это очень редкий юзкейс, заняло это 5 минут, и в отличии от готовых инстументов, у меня была полная власть над логикой визуализации.

Итак, подводя итог, можно сказать, что идеи Джека Рашера актульны и все они так или иначе реализованы в разных проектах. Видимо, единственное, на что жалуется автор - нет одного инструмента, в котором есть все. Но как я уже показал, большинство интсрументов нацелены на широкий спектр задач, внедрение каждой из идей требует компромиссов, а введение их все в разумном варианте практически невозможно. Но держать эти идеи в голове все-таки важно, и разрабатывая новую систему стоит если не внедрять их в идеальной и наиболее функциональной форме, то хотя бы придерживаться их принципов, давая разработчикам удобные инструменты для работы.


P.S. Забавно, что все набросы Рашера на программировние коррелируют с моими набросами на CI/CD. Вас не бесит невозможность проверить состояние раннеров, узнать детально, почему была вызвана та или иная джоба, отсутствие возможности влиять на процесс сборки? При этом CI, в отличи от программ нельзя дотюнить "сбоку", потому что весь контроль находится со стороны сервиса.
