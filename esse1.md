# ~~The Problem with Threads~~ Thread Considered Harmful


## Проблемы многопоточного программирования

Эдвар Ли, обеспокоившись доминированием многопоточного программирования для решения задач параллельных вычислений, указывает на проблемы данного подхода и предлагает альтернативные решения.

Главной проблемой параллельных систем, по мнению автора, является неопределенное поведение. Эвдард Ли приводит математическую модель последовательной вычислительной машины и показывает, как добавление в эту модель всего одного параллельного потока делает ее поведение непредсказуемой. Таким образом, и без того разработка сложных параллельных систем становится еще сложнее, а предотвращение багов - практически невозможным.

Далее автор приводит пример простой программы на Java, реализующей шаблон Наблюдатель - уведомления об обновлении значения рассылаются по зарегистрированным подписчикам. Данная программа отлично работает в одном потоке, но параллельное выполнение приводит к нарушению порядка уведомления, разным "картинам мира", которые видят подписчики и возможным дедлокам. При этом наивные подходы к решению этих проблем при помощи synchronized не решают всех проблем и полное решение является нетривиальным. И не стоит забывать, что, пытаясь починить многопоточность, мы жертвуем читаемостью и поддерживаемостью кода.


## Подходы к решению проблем многопоточного программирования

После этого автор переходит к описанию подходов к решению проблем многопоточного программирования.

Первый из них - строгие процессы разработки. В качестве примера автор приводит собственный проект Ptolemy II - программу для моделирования взаимодействия параллельных систем. Очевидно, Ptolemy II был глубоко завязан на многопоточность, и командой были приняты меры для предотвращения ошибок: множество регрессионных тестов, полностью покрывающих код; система оценки готовности кода; привлечение экспертов в области параллельных вычислений для независимого анализа; тестирование на процессорах и системах с разными моделями многопоточности. Но все эти меры не помогли избежать проблем - более чем через 4 года стабильной работы в системе произошел дедлок. Это еще раз показывает, что без формальных доказательств, неприменимых к большинству многопоточных систем, нельзя быть уверенным в ее корректности, а тесты и анализ помогают лишь найти ошибки, но не доказать их отсутствие.

Автор также упоминает программные средства статического анализа кода, пытающиеся найти ошибки в многопоточных программах. Но, как уже было сказано, без строгой математической модели найти ошибки крайне сложно.

Еще одним способом предотвращения ошибок многопоточных программ, упомянутых автором, является использование шаблонов проектирования и архитектурных стилей. Это позволяет переложить ответственность за ошибки на авторов подходов и инструментов, уменьшить количество самописного и более опасного кода. В дополнение к этому такие шаблоны могут навязываться языком, например, добавлением их в стандартную библиотеку или в синтаксис языка. Автор приводит примеры языков, включающих в себя команды управления параллельным исполнением - Cilk, Split-C. Здесь я хотел бы упомянуть современные проявления этого подхода - Go, предоставляющий ключевое слово `go` для запуска потока и языки со структурным асинхронным программированием - Rust, Kotlin, Python, JS/TS, позволяющи организивавывть работу асинхронных функций при помощи конструкций `async`, `await`, `async for` и тд. Помимо этого данные языки явно навязывают определенные подходы к параллельному программированию - взаимодействие через каналы, использование корутин и тд.

Также автор упоминает те шаблоны проектирования, что кажутся ему интересными - транзакции, MapReduce и Promises (Futures). Я бы хотел немного подробнее пробежаться по этим шаблонам.

### Транзакции

Использование транзакций подразумевает "оптимистичное" исполнение кода - действие всегда выполняется, но его результат может быть отменен, если за время исполнения данные были изменены другой транзакцией. Такой подход эффективен и удобен, когда главной сущностью вашей системы являются данные. Помимо очевидного примера использования - СУБД, я бы хотел привести еще один - системы контроля версий. Так, `git` явно реализует транзакционную модель - каждый коммит является транзакцией, которая может быть принята (merge) или отклонена (merge conflict). Отсюда можно сделать вывод, что и другие концепции работы с git применимы и к базам данных - rebase, checkout и merge проявляют те же проблемы, что и миграции; удаленные и локальные репозитории взаимодействуют также как мастер и реплики СУБД.

### MapReduce

MapReduce позволяет разделить задачу на независимые части, которые затем обрабатываются распределено и собираются в один результат. Метод был разработан в Google для обработки петабайт данных на распределенном кластере из тысячи машин. Также примерами использования этого опдхода являются системы обработки больших данных - Hadoop, Spark, Flink. Этот подход оказывается не только эффективным, но и удобным. Абстракции map и reduce, пришедшие из функционального программирования, отражают очень естественный подход к решению задач, привычный людям. Для большинства функциональных языков такой подход является стандартным, что делает написание параллеьнго кода выразительным и простым. Вот такой пример помещен на главной странице языка [Gleam](https://gleam.run/):
```gleam
pub fn main() {
  // Run loads of threads, no problem
  list.range(0, 200_000)
  |> list.map(spawn_task)
  |> list.each(task.await_forever)
}
```

Помимо этого, многие императивные языки программирования добавляют в себя абстракции map и reduce. Так одним из главных нововведений в Java 8 стал Stream API.

### Promises (Futures)

Promises, по-моему, является одним из самых удачных подходов к написанию параллельных программ. Вызов асинхронных функций при использовании Promises оборачивается в объект, с которым мы можем работать как с уже полученными данными. Несмотря на то, что данный подход менее выразительный, чем использование средств функционального программирования, он позволяет писать асинхронный код так же, как и синхронный, что позволяет ему естественно выглядеть в императивном коде. При этом ответственность за управление состоянием асинхронных задач переносится с разработчика на рантайм языка.


## Альтернативные подходы к параллельным вычислениям

Автор переходит к подходам взаимодействия частей параллельных вычислений, отличающихся от многопоточного. В качестве примера автор использует шаблон Наблюдатель, упомянутый ранее.

Для описание альтернативных подходов автор использует моделирование взаимодействия потоков при помощи Ptolemy II, что позволяет наглядно видеть отсутствие дедлоков, гонок и явно показывает неопределенности в системе. к тому же, лишь изменяя терминологию, мы можем описать одной моделью разные подходы к параллельным вычислениям. Так, все нижеперечисленные методы отличаются лишь каналами взаимодействия между потоками.

Первый подход, описываемый автором - Rendezvous (Барьер). Два потока, связанных барьером, дожидаются друг друга, выполняют обмен и продолжают исполнение. Это стандартный подход к взаимодействию потоков в многопоточных системах, который можно реализовать при помощи примитив синхронизации. Мне этот формат взаимодействия напоминает обмен запросами в TCP, когда принимающая и получающая стороны дожидаются друг друга и подтверждают получение данных.

Второй подход - взаимодействие через сети процессов Кана. Барьеры в таком случае заменяются на отправку сообщений, при этом порядок сбора сообщений явно обозначен как неопределенный. Такой подход позволяет отложить обработку сообщений и сделать части системы более независимыми. Современным примером такого подхода является язык Go, где общепринятым способом взаимодействия между потоками является каналы.

Третий подход - реактивная модель. В данном подходе модели реагируют на события, могут дожидаться их или прерывать исполнение. Этот подход является очень выразительным для решения задач в системах реального времени. Автор также приводит специальные системы для описания синхронно-реактивного подхода Esterel, Lustre, Signal. Сейчас такие подходы активно используются в разработке интерфейсов и веб-приложений. Так, например, происходит обработка событий в браузерном окружении.

И последний подход - модель учета временных задержек. При данном подходе учитывается время взаимодействия между частями системы. Различные состояния и временные промежутки могут быть описаны при помощи языков, поддерживающих временные аспекты - VHDL, Verilog, Opnet Modeler. Данные подход применяется в системах, где время является критичным фактором - сети, электронные схемы.

Я также хотел бы упомянуть модель акторов, которая является еще одним способом организации параллельных вычислений. В данной модели каждый актор является независимым исполнителем, обладающим своим состоянием и способностью общаться с другими акторами при помощи сообщений. Примерами языков, поддерживающих модель акторов, являются Erlang, Elixir, Akka (Scala). Возможно, многим эта модель знакома из распределенных систем с использованием микросервисов и брокеров сообщений.

## Сложности и возможности

В конце автор рассуждает о возможности применения этих подходов. Он говорит о том, что многопоточное программирование является не единственным способом решения задач параллельных вычислений, а перечисленные альтернативные подходы существуют и используются уже давно. Проблемой является их распространение и интеграция с существующими решениями. Автор еще раз обращается к идее внедрения параллельного программирования в синтаксис и семантику языков, и говорит о том, что мы должны не создавать новые системы, а интегрировать новые подходы в существующие. Эдвард Ли приводит пример новой математической модели вычислителя, учитывающей параллельные вычисления и делающей их предсказуемыми и приводит примеры ее реализации.

В конце автор подчеркивает две основные идеи. Сложность многопоточного программирования уже не может быть охвачена людьми, поэтому, пока мы не погрязли в ненадежном и неподдерживаемом программном обеспечении, мы должны искать альтернативы. Модели, к которым мы перейдем, должны быть предсказуемыми, ведь чтобы дастичь надежного результата, мы должны использовать средства, чье поведение можем предсказывать.


## P.S.

Мне хотелось бы добавить немного собственных размышлений о проблеме параллельных систем. Из текста статьи можно сделать вывод о том, что основной источник не определенность работы системы на определенном шаге и источником не определенности действий является изменение состояния.

Мне кажется, что лучший способ предотвратить неопределенность - улучшить контроль над изменением данных. Этот же вывод напрашивается из математических моделей вычислений, где данные являются неизменяемыми. Такой подход применяется в функциональных языках. Рассматривая данные как неизменяемые мы получаем четкую и детерминированную модель работы программы и можем контролировать ее поведение. Также это дает нам строгую математическую модель и возможность применения к нашей системе формальных методов верификации.

Я бы хотел привести пример языка, реализующего все вышеизложенные концепции - навязывание архитектуры, ее структурную поддержку на уровне синтаксиса, не изменяемую модель данных и каналы коммуникации, асинхронные по своей природе.

Язык [Elm](https://elm-lang.org/) является функциональным языком программирования для, неожиданно, написания фронтенд-приложений. Приложения, написанные на Elm, строятся на Elm Architecture, которую позже унаследовали и многие популярные фреймворки и библиотеки, такие как Ice (Rust) и Redux (TypeScrit). Elm Architecture представляет из себя модель, где приложение разделено на три части - Model, View и Update. Model - это неизменяемое состояние приложения, View - функция, преобразующая состояние в представление, Update - функция, преобразующая состояние приложения в новое состояние.

Все взаимодействия между частями приложения происходят через отправку сообщений. Так, при нажатии на кнопку из View будет отправлено сообщение в Update, который обработает его и вернет новую Model. События браузера так же преобразуются в сообщения и обрабатываются в Update. Отсутствие состояния внутри компонентов и явного взаимодействия позволяет легко обрабатывать все действия асинхронно. При этом параллельная обработка реализуется самим языком, а не программистом.

Благодаря неизменяемости на модели внутри компонентов состояние приложения легко описывается при помощи конечных автоматов, что делает его предсказуемым и понятным. Это так же дает простор для приминения продвинутых методов верификации и тестирования.

Таким образом, Elm является подтверждением идей, предложенных в статье, и моих дополнений, и демонстрирует возможность создания предсказуемых и надежных систем при помощи новых подходов к параллельным вычислениям.
